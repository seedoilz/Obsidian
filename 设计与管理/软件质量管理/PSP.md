---
aliases:
  - 个体软件过程
title: PSP
date created: 十二月 24日 2023, 7:20:02 晚上
date modified: 三月 5日 2024, 4:07:11 下午
tags: [management]
---

## 概念
> PSP是一种个体级用于管理和改进软件工程师个人工作方式的持续改进过程。是包括数据记录表格、过程操作指南和规程在内的结构化框架。
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/17.png)

## PSP基本原理(为什么有PSP)
1. 软件系统的整体质量由该系统中质量最差的组件所决定。
2. 软件组件的质量取决于开发工程师所使用的开发过程。
3. 软件工程应当自己度量、跟踪自己的工作流程，并建立持续的自我改进机制，自己管理软件组件的质量。

## PSP成熟度级别
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/18.png)

## PSP质量管理
1. 质量管理是对质量的管理，必须包含管理三要素。
2. 质量实践包括测试等等
### PSP的质量观与质量策略
1. 软件项目的日程、成本及质量三大目标统一于质量目标
2. 软件质量是与软件产品满足规定和隐含的需求能力有关的特征或者特征的全体。
   1. 软件质量的内外两部分的特性
      1. 内部质量特性：不直接面向用户
      2. 外部质量特性：面向软件产品的最终用户
   2. 软件质量的不同视角
      1. 软件质量为软件产品可以改变世界，使世界更加美好的程度(用户满意度是最为重要的判断标准)
      2. 软件质量是对人的价值，强调质量的主观性(对同一款软件而言，不同的用户对其质量有不同的体验)
3. 面向用户的质量观
   1. 定义需求为满足用户需求的程度
   2. 这个定义中需要进一步明确：用户究竟是谁？用户需求的优先级是什么？用户的优先级对软件产品的开发过程产生什么影响？怎么度量这种质量观下的质量水平？
   3. 指导意义：开发在前，运维在后；高质量开发确保DevOps中的价值顺畅流动；个体软件工程师的技能、过程直接影响产品质量；PSP关注提升个体软件工程师工程技能
4. 质量策略：
   1. 使用缺陷管理来代替质量管理
      1. 首先确保没有缺陷，然后再考察其他的质量目标。高质量的产品也就意味着软件产品的各个组件基本无缺陷。
      2. 为什么有效？通过关注每个组件的质量可以避免在测试阶段消除缺陷，减少消除代价，提高生产效率。
   2. 各个组件的高质量是通过**高质量评审**来实现的

### 质量路径(8个步骤)

1. 各种测试
2. 进入测试之前的产物质量提升
3. 评审过程度量和稳定
4. 质量意识和主人翁态度
5. 个体review的度量和稳定
6. 诉诸设计
7. 缺陷预防
8. 用户质量关 —— 其他质量属性

### 评审与测试
1. 测试消除缺陷
   1. 发现待测程序的一个异常行为
   2. 理解程序的工作方式
   3. 调试程序，找到出错的位置，确定出错的原因
   4. 确定修改方案，修改缺陷
   5. 回归测试，以确认修改有效
2. 评审消除缺陷
   1. 遵循评审者的逻辑来理解程序流程
   2. 发现缺陷的同时，发现了缺陷的位置和原因
   3. 修正缺陷
3. 评审形式：打印后评审效果更好
   1. 单个屏幕可以展现的内容比较有限：不能完整展示整体结构、安全、性能等
   2. 使用屏幕的评审，评审人员的注意力容易被分散
4. 评审时机
   1. 先编译后评审
      1. 对于某些类型的缺陷而言，通过编译发现并消除缺陷的效率是通过评审发现并消除的数倍。
      2. 一些基于解释执行的集成开发环境，可以消除编译错误。
   2. 先评审后编译
      1. 节省编译阶段的时间：评审的速度和时间是一定的。
      2. 解决编译器遗漏的缺陷。
      3. 编译前评审是良好的学习机会，同时干净的编译给软件工程师带来极大的成就感。
5. 评审的具体形式：先个人评审后小组评审
   1. 小组评审有利于更好的发现缺陷，预防风险，提高Process Yield来确保质量。
   2. 个人评审后安排小组评审，有利于提升个人技能。
6. 评审预防过程中的缺陷数据选择
   1. 选择那些在**系统测试、验收测试以及应用环节出现**的缺陷，特别是验收测试和应用环节中的缺陷，这些缺陷往往意味着软件开发过程本身有不足之处。
   2. 选择那些在**出现频率较高或者消除代价较高**的缺陷，这些缺陷如果可以预防，往往可以节省较多开发的代价，从而体现缺陷预防的优势。
   3. 选择那些**预防方法容易识别和实现**的缺陷，这样的策略容易让软件工程师迅速看到缺陷预防的好处，鉴定使用缺陷预防策略的信心。

## PSP度量
### 基本度量项

1. 度量时间：序号、所属阶段、开始时间、结束时间、中断时间、净时间、中断原因
2. 度量缺陷：序号、发现日期、注入阶段、消除阶段、消除时间、关联缺陷、缺陷产生原因
3. 度量规模：使用PROBE估算方法
4. 度量日程(TSP)

#### 规模度量标准

1. 选择的度量方式必须反映开发成本。
2. 选择的度量方式必须精确。
3. 选择的度量方式必须能用自动化方法来统计。
4. 选择的度量方式必须有助于早期规划。

#### 规模度量的困境

1. 精确的度量方式往往不便于早期规划。
2. 有助于早期规划的度量往往难以生成精确度量结果。

#### 解决方案：PROBE方法

1. 估算原理
   1. 设计合理的代理作为精准度量和早期规划所需要的度量之间的桥梁
   2. 使用相对大小而不是绝对大小
2. 方法特点：非常依赖高质量的历史数据，一旦数据不完整或者缺失，则会导致估算结果有偏差。
3. 估算过程：估算是相关干系人达成一致共识的过程。
   1. 概要设计，确认产品功能，明确所需的程序组件/模块，将这些组件/模块与之前缩写的程序比较，估算规模，得到总规模。
   2. 估算要点：尽可能划分详细一些、建立对结果的信息、依赖数据、估算关注的是过程而不是结果。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/2.png)

4. 估算方法：以估算规模为例
   1. 简单方法
      1. $VS = \min, S = \frac{VS + M}{2}, M = median, L = \frac{M + VL}{2}, VL = \max$
      2. 计算简单，但是不稳定
   2. 正态分布法
      1. $VS = M - 2\sigma, S = M - \sigma, M, L = M + \sigma, VL = M + 2\sigma$，均值为$M$，标准差为$\sigma$
      2. 相对稳定，在历史数据基本符合正态分布的情况下，可以给出非常好的相对大小矩阵
   3. 对数正态分布法
      1. 首先计算所有的数据的自然对数(以e为底)，得到之后的数据的均值$M$，标准差$\sigma$，之后VS、S、M、L、VL计算方法同正态分布法，然后取反对数
      2. 优点：符合人们对程序规模的直观感觉，大多数人习惯写大量规模小的程序，少量规模大的程序
   4. 线性回归方法
      1. 项目所需的资源并不是直接由程序规模和历史数据中的生产效率相处得到。为什么？因为程序规模和生产效率都在一个范围内波动，如果直接相除会导致更大误差。
      2. 估算了一定概率条件下的估算值的分布。
      3. Range是一定条件下的变化区间，p为概率
      4. Variance是扰动程度：有时候，历史数据中的一些极端数据会造成相关性假象，因此需要先进行数据降噪

$$
\begin{array}{l}
Plan\ Size = \beta_{0\ size} + \beta_{1\ size}(E) \\
Plan\ Time = \beta_{0\ time} + \beta_{1\ time}(E) \\
Range = t(p,df)\delta\sqrt{1 + \frac{1}{n} + \frac{(x_k-x_{avg})^2}{\sum\limits_{i=1}\limits^{n}(x_i-x_{avg})^2}} \\
Variance = \delta^2 = \frac{1}{n-2}\sum\limits_{i=1}\limits^n(y_i - \beta_0 - \beta_1x_i)^2 \\
\end{array}
$$

5. 处理有限的历史数据
   1. 为什么可以使用历史数据完成，使用代理规模与实际程序规模之间的关系完成规模估算？因为规模估算产生偏差的原因相对客观，偏差可以用来修正新的估算结果。
   2. 为什么时间估算的偏差产生原因更加复杂：一方面和规模有关，另一方面和人的主观能动性有关。

> 其中r为相关性(两组数据之间相互关联的程度，PSP中要求r>= 0.7)，其中S为显著性(两组数据的相关关系出现的偶然性，PSP要求s<=0.05)

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/12.png)
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/19.png)

### 衍生度量项

#### Yield指标

1. 定义了每个阶段在消除缺陷方面的效率。越大越好，希望在80以上。
2. Yield指标是一种事后的质量控制手段，很难非常精确地计算。

$$
\begin{array}{}
Phase\ Yield = 100 * \frac{某个阶段发现的缺陷个数}{某个阶段注入的缺陷个数 + 进入该阶段前遗留的缺陷个数} \\ \\
Process\ Yield = 100 * \frac{第一次编译前发现的缺陷个数}{第一次编译前注入的缺陷个数}
\end{array}
$$

2. 例子：

| 阶段        | Injected | Removed | remain | Yield      |
| ----------- | -------- | ------- | ------ | ---------- |
| DFD         | 10       | 0       | 10     | 0          |
| DFD REVIEW  | 0        | 4       | 6      | 40         |
| CODING      | 20       | 2       | 24     | 1/13 * 100 |
| CODE REVIEW | 0        | 12      | 12     | 50         |
| UNIT        | 0        | 12      | 0      | 100        |

> IBM：最后的测试如果发现了一个错误，那么其中一定还有一个错误没有被发现（所以最后的Yield的值为50）

| 阶段        | Injected | Removed | remain | Yield      |
| ----------- | -------- | ------- | ------ | ---------- |
| DFD         | 10+4     | 0       | 14     | 0          |
| DFD REVIEW  | 0        | 4       | 10     | 2/7 * 100  |
| CODING      | 20+8     | 2       | 36     | 2/19 * 100 |
| CODE REVIEW | 0        | 12      | 24     | 1/3 * 100  |
| UNIT        | 0        | 12      | 12     | 50         |

3. 基于Yield指标构建缺陷预测模型，并列举该模型的可能改进方案
   1. 总体思想：利用回归技术预测软件开发过程中各阶段的Inject Rate(缺陷注入率)和Yield(缺陷消除率)
   2. Yield指标只能用来估算，不可以用来度量。结合Yield指标和上图，只需要知道如下指标就可以基于Yield指标构建一个基本的缺陷预测模型：
      1. 注入阶段注入多少缺陷
      2. 缺陷注入的密度（需求每一页注入多少缺陷）
      3. 缺陷注入的速度（每小时注入多少缺陷）
      4. 消除阶段的缺陷注入密度和速度。
      5. 历史数据中的软件规模、文档规模、开发人员规模
   3. 步骤
      1. 确定纳入影响因子的数据以及数据度量方法
      2. 从系统历史库中收集历史数据，并进行整理
      3. 依照回归技术进行计算
      4. 在项目进行过程中不断收集数据，与预测数据进行比较，调整回归参数
      5. 项目过程中依据实际数据与预测数据的误差进行风险的预防、识别和控制
   4. 改进方案
      1. 维护历史数据：历史数据在简单性、可理解性、稳定性、可度量性、相关性等方面的质量都有影响。
      2. 影响因子的选择：不仅仅有软件规模的数据，还需要有开发过程、文档、人员等方面的数据，并将其可度量化。
      3. 反馈模型：随着开发实际数据的产生，将这些数据作为输入变量放回模型来调整参数。
      4. 蒙特卡洛方法：假设注入水平和消除水平都符合正态分布，计算均值和标准差并用蒙特卡洛方法模拟结果。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/3.png)

#### A/FR

1. COQ(Cost of Quality)
   1. 失效成本：分析失效现象、查找原因，做必要的修改所消耗的成本
   2. 质检成本：评价软件产品，确定其质量状况所消耗的成本
   3. 预防成本：识别缺陷根本原因、采取措施预防其再次发生所消耗的成本
2. 质检失效比
   1. A/FR = PSP质检成本 / PSP失效成本
   2. 质检成本 = 设计评审时间 + 代码评审时间
   3. 失效成本 = 编译时间 + 单元测试时间
3. 理论上，A/FR值越大，意味着质量越高，但A/FR值过大说明评审过多，则开发效率低下，因此PSP中A/FR期望值为2.0

#### PQI

1. 为5个数据的乘积(以基准值作为1，最后结果越接近1，质量越高)
   1. 设计质量：设计时间应该大于编码时间，$\min(\frac{设计时间}{编码时间}, 1)$
   2. 设计评审质量：设计评审的时间应该大于设计时间的50%，$\min(2 * \frac{设计评审时间}{设计时间}, 1)$
   3. 代码评审质量：代码评审时间应该大于编码时间的50%，$\min(2 * \frac{代码评审时间}{编码时间}, 1)$
   4. 代码质量：代码的编译缺陷密度应当小于10个/千行，$\min(\frac{20}{编译缺陷密度 + 10}, 1)$
   5. 程序质量：代码的单元测试缺陷密度应当小于5个/千行，$\min(\frac{10}{单元测试缺陷密度 + 5}, 1)$
2. 用途：判断模块开发质量、规划质量活动、过程改进。

####  Review Rate

1. 评审的速度是一个用以指导软件工程师开展有效评审的指标
2. 代码评审速度小于200 LOC(代码行)/h
3. 文档评审速度小于4 page(文档采用页)/h

#### DRL Defect-Removal-Leverage 缺陷消除效率比

1. 缺陷消除效率比：不同缺陷消除手段消除缺陷的效率
2. 计算方法：以**某个测试阶段(一般为单元测试)每小时发现的缺陷数为基础，其他阶段每小时发现缺陷数与该测试阶段每小时发现的缺陷的比值**就是DRL

#### 度量的作用

1. 度量体现着决策者对试图要实现的目标的关切程度。
2. 度量帮助过程的实践者了解过程状态，理解过程偏差。

## 考试题

> 对比度量方式 LOC 和 FP

1. LOC
   1. LOC优点：LOC是软件开发项目的生成品，容易进行计算
   2. LOC缺点
      1. LOC测量依赖于程序设计语言，不同语言产生结果存在偏差
      2. 对代码量少但设计精巧的程序产生不利评判
      3. 不适合非过程语言
      4. 在软件项目开发前或开发初期估算代码行数非常困难
2. FP
   1. FP优点
      1. 和程序设计语言无关
      2. 面向过程和非过程语言均适合
      3. 基于项目开发初期就可能得到的数据
   2. FP缺点：计算基于主观而非客观数据
3. 随着软件工程产业化分工加剧专门从事软件下游基础业务的商业组织增多，使得基于LOC的度量方式逐渐失去意义，而基于FP的度量方式显得更加符合要求

> 请结合A/FR、PQI、Review Rate、DRL、Yield尽可能具体描述⼀个软件项⽬应该如何
> 从多⽅⾯来确保开发的⾼质量（本题满分10分）

这些指标既是开发过程中质量管理的⼀些参考指标，同时也体现在计划安排中应该注意的
质量元素。具体如下：

1. 在项⽬计划过程中应该安排确保⾼质量开发结果的活动，例如，按照A/FR、PQI等指标
   的要求，安排对各类产物（⽂档和代码）的个⼈评审和⼩组评审；
2. 这些评审活动应该满⾜⼀定的要求，特别体现在时间⽅⾯。例如，评审时间应该多于
   测试时间的两倍以上（A/FR）；评审时间应该是相应开放时间的50%以上（PQI）；评
   审速度要求（Review Rate）等
3. 充分借鉴质量指标所体现的开发质量状况，尽早制订相应的质量补救措施。例如，PQI
   所体现的缺陷密度、所有上述指标的参考值等等。⼀旦超标，往往意味着质量⽅⾯有
   偏差，应当及时补救。
4. 利⽤yield等指标，构建质量预测模型，更加积极（Proactive）地判定和控制开发质量；
5. 依据PQI和Yield指标所体现的信息，通过过程改进来提升开发质量。

## 通用计划框架

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/1.png)

1. 上述框架中，那些步骤必须人为的干预
   1. 定义需求
   2. 概要设计：划分由人为开始，规模划分好之后估算是自动产生的
   3. 日程计划
2. 这会带来什么的好处？比较容易扛住别人的质疑。
   1. 攻击点：资源和时间是否被高估了
   2. 解决：估算没有代码行PROBE只有功能点是大中小。
3. 考试题：【2020-mid】请简要描述按照通用计划框架，为了开发合理的项目计划，应该要做哪些估算？PROBE方法充当什么角色。
   1. 估算框架如上图
   2. 虚线框即为PROBE，用来完成规模和资源的评估

## 个体软件过程的设计

1. 设计 vs. 质量
   1. 低劣的设计是导致在软件开发中返工、不易维护以及用户不满的主要原因。
   2. 充分设计可以显著减少最终程序的规模，提升质量
   3. 设计本身也是一种排除错误的过程。
2. 设计内容：设计目标程序
   1. 在整个系统内的位置
   2. 使用的方式
   3. 与其他组件以及模块之间的关系
   4. 外部可见的变量和方法
   5. 内部运作机制
   6. 内部静态逻辑
3. 设计的过程

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/exam/21.png)

4. 四种设计模块
   1. 操作规格模板(Operation Specification Template)：描述系统与外界的交互，定义测试场景和测试用例。
   2. 功能规格模板(Functional Specification Template)：描述系统的对外接口，用形式化符号描述方法行为，消除二义性。
   3. 状态规格模板(State Specification Template)：精确定义程序的所有状态、状态之间的转换以及伴随每次状态转换的动作。
   4. 逻辑规格模板(Logical Specification Template)：精确描述系统的内部静态逻辑，使用伪代码配合形式化符号来消除二义性。

|          | 动态信息                        | 静态信息                        |
| -------- | ------------------------------- | ------------------------------- |
| 外部信息 | 交互信息(服务、消息等), OST/FST | 功能(继承、类结构等)，FST       |
| 内部信息 | 行为信息(状态机)，SST           | 结构信息(属性、业务逻辑等)，LST |

5. 不同的设计层次

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec5/9.png)

6. 设计验证方法
   1. 状态机验证
      1. 检查状态机，消除死循环和陷阱状态：使用状态机
      2. 检查状态转换，验证完整性(任何一个状态+任何一个条件的组合的下一个状态转换都有定义)和正交性(状态机中任何一个状态的下一个状态的转换条件都不能相同)：使用真值表
      3. 评价状态机，检验是否体现设计意图
   2. 符号化验证：实施简单，适合不复杂的算法(遗漏系统的改造)；不适合复杂逻辑的场合，纯手工验证方法容易引入错误。
      1. 识别为伪码程序中的关键变量
      2. 将变量使用代数符号表示，重写伪码程序
      3. 分析伪码程序的行为
   3. 执行表检查：实施简单，结果可靠，可用于复杂逻辑的验证；每次只能验证一个用例，手工验证比较耗时，容易引入错误。
      1. 识别伪码程序的关键变量
      2. 构建表格，表格左侧填入主要程序步骤，右侧填入关键变量
      3. 初始化被选定的变量
      4. 跟踪被选择的关键变量的变化情况，从而判断程序行为
   4. 跟踪表验证：通过符号化、用力识别等方法对程序的一般化行为进行验证，是执行表验证的补充，可以每次验证多个用例。
      1. 识别伪码程序的关键变量
      2. 构建表格，表格左侧填入主要程序步骤，右侧填入关键变量
      3. 初始化被选定的变量
      4. **识别将伪码程序符号化的机会，并加以符号化**
      5. **定义并且优化用例组合**
      6. 跟踪被选择的关键变量的变化情况，从而判断程序行动
   5. 正确性验证：将伪码程序作为数字定理，采用形式化方法加以推理和验证。
      1. 分析和识别用例
      2. 对于复杂伪码程序的结构，应用正确性验证的标准问题逐项加以验证
      3. 对于不能明确判断的复杂程序结果，使用跟踪表等辅助验证