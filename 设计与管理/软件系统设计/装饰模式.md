---
aliases: [Decorator Pattern]
date created: 2023-04-17 16:04:00
date modified: 2024-03-20 11:03:77
title: 装饰模式
tags: [software-design/pattern]
---

## 定义
装饰模式 (Decorator Pattern) ：**动态地给一个对象增加一些额外的职责**(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为**包装器**(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为"油漆工模式"，它是一种**对象结构型模式**。

## 结构
1. Component: 抽象构件
2. ConcreteComponent: 具体构件
3. Decorator: 抽象装饰类
4. ConcreteDecorator: 具体装饰类
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec08/9.png)

## 分析
### 优点
1. 可以提供比继承更多的灵活性。
2. 可以通过动态的方式来扩展一个对象的功能，通过配置文件在运行时选择不同装饰器。
3. 通过使用不同的具体装饰类和这些装饰类的排列组合，可以创造出很多不同行为的组合 (多个装饰者装饰一个对象)
4. 具体构件类与具体装饰类可以独立变化，增加新的具体构件类和具体装饰类使用时仅需要组合，符合 “[[开闭原则]]”

### 缺点
1. 产生很多的小对象，他们之间的区别仅仅是连接方式不同，同时还产生很多具体装饰类，这些具体装饰类和小对象会增加系统的复杂度，加大学习与理解的难度。
2. 比继承更灵活机动的特性，意味着装饰模式比继承更容易出错且难以排查 (需要逐级排查)，较为繁琐

### 适用场景
1. 不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。
2. 需要动态地给一个对象增加功能，也要动态地取消这些功能。
3. 当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。不能继承的情况分两类: 其一是大系统存在大量独立的扩展，为支持每一种组合将产生大量子类，呈现爆炸式增长; 第二是类定义为不能继承 (final)

#### 实例
变形金刚在变形之前是一辆汽车，它可以在陆地上移动。当它变成机器人之后除了能够在陆地上移动之外，还可以说话；如果需要，它还可以变成飞机，除了在陆地上移动还可以在天空中飞翔。
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec08/10.png)

某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-Software-System-Design/img/lec08/11.png)